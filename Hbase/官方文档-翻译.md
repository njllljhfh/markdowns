# Hbase

[官方文档](http://hbase.apache.org/book.html)



## 37. 行键设计（Rowkey Design）

### 37.1. Hotspotting

​		Hbase中的行用行键（row key ）来保存，行键按字典序排序。这种设计优化了扫描（scans），允许您存储相关的行，或将可能一起读取的行彼此相邻。然而，糟糕的行键设计是 *hotspotting* 常见原因。当大量客户端流量被定向到集群的一个节点或几个节点时，就会发生 Hotspotting 。此处流量可以表示读、写或其他操作。流量使负责托管该区域（region ）的单机不堪重负，导致性能下降，并可能导致区域不可用。这也可能对***同一区域服务器***所承载的其他区域产生不利影响，因为该主机无法为请求的负载提供服务。为了充分、均匀地利用集群，数据访问模式的设计尤为重要。

​		为了防止写操作上的Hotspotting ，将行键设计为确实需要位于同一区域的行，但从更大的角度来看，数据是跨集群写入多个区域，而不是一次写入一个区域。下面介绍了一些常见的避免Hotspotting 的技术，以及它们的一些优点和缺点。



#### *Salting*

​		这种意义上的盐与密码学无关，而是指在行键的开始添加随机数据。在本例中，salting指的是向行键添加随机分配的前缀，以使其排序不同于其他方式。可能的前缀的数量对应于您希望将数据分散到的区域的数量。*如果您有一些“热”行键模式，这些模式会在其他更均匀分布的行之间反复出现，那么使用盐可能会有所帮助。（Salting can be helpful if you have a few "hot" row key patterns which come up over and over amongst other more evenly-distributed rows.）* 考虑下面的示例，它显示了salting可以将写负载分散到多个region服务器上，并说明了对读操作的一些负面影响。

Example 10. Salting Example:

​		假设您有下面的行键列表，并且您的表被分割为每个字母对应一个区域。前缀“a”是一个区域，前缀“b”是另一个区域。在这个表中，所有以 f 开头的行都在同一个区域内。这个例子中的行键如下:

```
foo0001
foo0002
foo0003
foo0004
```

​		现在，想象一下，你想把这些信息分布到四个不同的地区。您决定使用四种不同的盐:a、b、c和d。在这种情况下，每个字母前缀将位于不同的区域。在应用盐之后，您将得到以下行键。由于现在可以写入四个不同的区域，所以理论上，当前写入时的吞吐量是所有写入操作都在同一区域时的四倍。

```
a-foo0003
b-foo0001
c-foo0004
d-foo0002
```

​		然后，如果您添加另一行，它将被随机分配四个可能的盐值中的一个，并位于现有行的下面一行。

```
a-foo0003
b-foo0001
c-foo0003
c-foo0004  # 新添加的一行
d-foo0002
```

​		因为这个盐的分配是随机的，所以如果想按照字典顺序检索行，就需要做更多的工作。通过这种方式，salting试图增加 ***写操作*** 的吞吐量，但是在 ***读操作*** 期间会增加开销。



#### *Hashing*

​		与随机分配不同，您可以使用单向 *hash* ，这种 *hash* 将使得给定的行始终使用相同的“盐”作为前缀，从而将负载分散到RegionServers，但使得读取变得可预测。使用确定性 *hash* 允许客户端重新构建完整的rowkey，并使用 Get 操作检索该行。

Example 10. Hashing Example:

​		与上面 *Salting* 示例中的情况相同，您可以应用单向 *hash*，使行键为 `foo0003` 的行始终（并且可以预见地）接收到 `a` 前缀。然后，要检索这一行，您已经知道该键值。你也可以优化一些东西，例如使某些特定的键值对总是在同一个区域。



#### *Reversing the Key*

​		防止Hotspotting 的第三个常见技巧是将固定宽度或数字行键反向，使行键中更改最频繁的部分（最低有效数字）位于第一个位置（即，最左边）。这有效地随机了行键，但是牺牲了行排序属性。